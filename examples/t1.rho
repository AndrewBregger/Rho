// #load "test.rho"
// conditional imports will be added later

#load "t2.rho"
#load "fmt.rho"

/*
#load "fmt.rho"

// renames the import identifer to t and only imports fun1 and fun2
#load "test.rho": t {
	fun1,
	fun2
}

// gets everything from the file and puts it into this file scope.
#load "test2.rho": *
*/

// type vec3 = Vector3f;

// type BinFunct = (a, b: int) -> int;

/*
foo :: (x: *f32) -> f32 {
	if x == 1
		return x - 1;
	else if x == 2
		return x - 5;
	else
    return x;
}

var a: i16;
var b: i32;
var b: Vector3f;

// current thoughts on how to syntactically represent conditional imports
//#load "io_win.rho": io {read, write} if __PLATFORM__ == WIN32


var b: Vector3f;

// lets are constant
let two = 2;

// map between primative types
var map: [i16, string];

// map between primative type and imported structure
var iomap: [string, fmt.io];

// constant expression being used as array size
var arr: [two * two]int;
var darr: [..]int;

let a = 14;
var a: byte;
var h = "Hello, World";
var g = 'd';
var c, d, e, f: string;

foo :: (x: *f32) -> f32 {
	if x == 1
		return *x - 1;
	else if *x == 2
		return *x - 5;
	else
    return *x;
}

foo2 :: (x: f32, y: f32) -> f32, f32 {
    return x, y;
}

foo3 :: (x: f32, y: f32) -> a: f32, b: f32 {
    a = x;
    b = y;
}

TriangleMesh :: class {
	vertices: [..]f32; //[..]Type is a dynamic array
	normals: [..]f32;
	indices: [..]u32;
	vbo: u32;
	vao: u32;
	id: i32 pub static;
}


// a member function that modifies the reciever, *TriangleMesh.
loadMesh :: *TriangleMesh (file: string) {

}

init_buffers :: *TriangleMesh () -> bool {

}

// a constant member function that doesnt modify the reciever.
draw :: TriangleMesh () {

}

Point :: struct {
	x, y, z: f32;
}

Point :: struct {
	// a it cant hand default values yet
	// x, y, z : f32 = 0;
	x, y, z : f32;
}
*/